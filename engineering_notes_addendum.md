# 工程文档补充：废弃“猜 FIFO 空 = 包结束”的错误实现（认错说明）

> 认错说明：之前接收侧用“FIFO 瞬时为空就当帧结束”的做法是错误的、且不可靠。这个做法在背靠背小包、RX 抖动、以及异步跨时钟场景下都可能误判帧尾，是“笑话代码”。现已**彻底移除**。

## 正确做法（已在当前版本实现）

- **帧界定**：严格使用 RGMII 的 `RX_CTL`（`RX_DV ⊕ RX_ER`）表示“数据有效”，在 DDR→8bit 的同等打拍后，**以 `RX_CTL` 的下降沿作为帧尾**。不再观察 FIFO Empty。  
- **对齐关系**：千兆/百兆路径在“拼 8 位”处各打一拍，`data_we`（写 MAC RX FIFO 的写使能）与 CRC 的 `crc_en` 使用**同一个**打拍后的使能信号，保证进入 CRC 的字节与写入 FIFO 的字节**一一对应**。  
- **FCS 处理**：前导码 + SFD **被滤掉**不进任何 FIFO；FCS 4 字节**跟随数据一起进入** MAC RX FIFO（因为实时不知道帧长无法提前丢弃）。CRC 模块内部用移位寄存器缓存“最后 4 字节”作为 FCS，同时**CRC 输入仍包括 FCS**。  
- **CRC 判定**：在帧尾（`RX_CTL` 下降沿）到来时，以太网 CRC32 的**固定残差**进行判断，使用的比对常数为 **`32'h2144_DF1C`**（当 CRC 计算包括 FCS 时应得到该残差）。匹配则 `crc_ok_pulse`，否则 `crc_err_pulse`。  
- **完全移除“猜空”**：`eth_crc32_stream_chk` 内部**没有**任何“看 FIFO Empty 判帧”的逻辑；仅依赖 `RX_CTL` 边沿 + 末尾 4 字节缓存 + 残差判断这条正路。

## 验证建议

1. 在 125MHz 域观察 `rx_byte`、`data_we`、同步/打拍后的 `rx_ctl_b`、`eof_pulse`、`last4`、`crc_residual`。  
2. 背靠背帧（FIFO 始终非空）仍应正常产生 `eof_pulse` 与 `crc_ok_pulse`，证明逻辑**不依赖“空”**。  
3. 暂停 `RXC` 不会误产生帧尾。

## 其他保持不变的约定

- **发送端**自动添加前导码 `(7×0x55)+0xD5`，尾部追加 FCS（调用 ROM IP `crc32_lut`，工程内不含同名 .v）；**PHY2 的 TX 链同样补齐**。  
- **时序**：`ODDRX1F` 送 TXD/TXCTL/TXC；TXC 的 2ns 延时放约束/IODELAY，不用 90° 相位的 PLL。  
- **上层处理**：后续由 IP 层依据 IPv4 Total Length 切用户负载，丢弃 FCS/填充；MAC 层不过度假设协议，保证“原样接收 + 规范校验”。

—— 以上内容已落实到当前 RTL 中，特此记录与更正。
